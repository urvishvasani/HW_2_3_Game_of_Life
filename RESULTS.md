# Results

## Method

1. For the initial setup of this experiment, we implemented Conway's Game of Life in three languages: Kotlin, Julia & Haskell and introduced two bugs in each implementation.
   - Compilation bug: To evaluate how helpful compiler is to navigate through the bug.
   - Logical bug: To evaluate the readability of language.
2. After the implementation, we let 10 participants sign up for our experiment and assigned each of the with a token to identify them anonymously. We setup a virtual meet of 30 minutes on zoom as per participant's preferred time for the upcoming debugging session.
3. During the scheduled debugging session:
   - Each session will be hosted and observed by 2 group members.
   - Participants will be required to share their screen for us to observe.
   - Debugger will follow instruction from the README file to perform the experiment. Session hosts will guide participant though the steps if needed.
   - Session hosts have permission to provide hints to participants to understand the bug after predefined threshold time. This factor will be considered for the final evaluation.
4. While participant is debugging, following observations will be noted by the session hosts:
   1. For each Kotlin, Julia and Haskell debugging experiment:
      1. Time taken to fix the compilation bug.
      2. Time taken to fix the logical bug.
      3. Used resources (i.e Internet search, Help from the session hosts)
   2. Did the participant use traditional backtracking approach to find the root cause of the error?
5. Post debugging session, participants are required to complete the survey in order to record their information about their background knowledge and comments for the debugging session. This survey includes:
   1. Familiarity with languages: Kotlin, Julia and Haskell prior this experiment.
   2. For each Kotlin, julia and Haskell debugging experiment:
      1. How helpful compiler's error messages were for Compilation error?
      2. How readable the code is to understand Logical error?
      3. How difficult these bugs were to solve?
      4. Which programming language resembles the most to this language?
   3. Ranking of relative difficulty from debugging perspective.
   4. Which language they are most likely to use in near future?

## Material
1. [Sign up sheet](https://docs.google.com/spreadsheets/d/1BKcw3SPB2JIysBe6Kw6mkylA_3Ja0o-eQ5TmNMgAZww/edit#gid=0)
2. Implementation with compilation and logical bug
   - [Kotlin](code/kotlin/GOL.kt)
   - [Julia](code/julia/GOL.jl)
   - [Haskell](code/haskell/GOL.hs)
3. [Instructions for the debugging session](https://github.com/urvishvasani/HW_2_3_Game_of_Life#how-to-run)
4. [Online IDE to perform the experiment](https://repl.it/github/urvishvasani/HW_2_3_Game_of_Life)
5. [Post debugging survey](https://docs.google.com/forms/d/e/1FAIpQLSeqIzBdJArD6M2HLxb0OIcmEGPh17jvUO845rWSREaaegU3qQ/closedform)
6. [Post debugging survey responses](https://docs.google.com/spreadsheets/d/1hthxqCVm0Dbk5fdAo-5iRvSGBeUH_mGzRias4YtLCZo/edit?usp=sharing)
7. [Observation from the session hosts](https://docs.google.com/spreadsheets/d/1o9TrwybYMLmB7scy8Pe4eh5sLlc40FrnlNM922uLtZE/edit?usp=sharing)

## Observations
add graphs based on the observations

## Conclusions

## Threats to validity
